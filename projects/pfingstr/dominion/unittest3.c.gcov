        -:    0:Source:unittest3.c
        -:    0:Graph:unittest3.gcno
        -:    0:Data:unittest3.gcda
        -:    0:Runs:4
        -:    0:Programs:1
        -:    1:
        -:    2:#include "dominion.h"
        -:    3:#include "dominion_helpers.h"
        -:    4:#include <string.h>
        -:    5:#include <stdio.h>
        -:    6:#include <assert.h>
        -:    7:#include "rngs.h"
        -:    8:#include <stdlib.h>
        -:    9:
        -:   10:#define CARD_TEST "Mine"
        -:   11:
        -:   12://gcc -o unittest3 dominion.c rngs.c unittest3.c
        -:   13:
function fakeAssert called 24 returned 100% blocks executed 100%
       24:   14:void fakeAssert(int i, int j, int *ErrCnt)
        -:   15:{
       24:   16:    if(i == j)
branch  0 taken 83% (fallthrough)
branch  1 taken 17%
        -:   17:    {
       20:   18:        printf("TEST %d PASSED\n", *ErrCnt);
call    0 returned 100%
        -:   19:    }
        -:   20:    else
        -:   21:    {
        4:   22:        printf("TEST %d FAILED\n", *ErrCnt);
call    0 returned 100%
        -:   23:    }
       24:   24:    *ErrCnt = *ErrCnt+1;
        -:   25:    
       24:   26:}
        -:   27:
function main called 4 returned 100% blocks executed 100%
        4:   28:void main() 
        -:   29:{
        -:   30:    int i;
        4:   31:    int handpos = 0, bonus = 0;
        4:   32:    int seed = 1000;
        -:   33:    //number of players
        4:   34:    int numPlayers = 2;
        4:   35:    int player=0;
        -:   36:    //each holds a pointer to game state variable
        -:   37:	struct gameState basePlayer, testPlayer;
        -:   38:    //Kingdom cards avaliable for purchase
        4:   39:	int k[10] = {adventurer, embargo, village, minion, mine, cutpurse,
        -:   40:			sea_hag, tribute, smithy, council_room};
        4:   41:    int ErrCnt = 1;
        -:   42:    int count, count2;
        4:   43:    count = count2 = 0;
        -:   44:
        -:   45:
        4:   46:    printf("TESTING - %s\n", CARD_TEST);
call    0 returned 100%
        -:   47:	
        -:   48:    // 1 Initialize a game state and player cards
        4:   49:    fakeAssert(initializeGame(numPlayers, k, seed, &basePlayer), 0, &ErrCnt);
call    0 returned 100%
call    1 returned 100%
        -:   50:
        -:   51:	//Copy the game state of player to testPlayer
        4:   52:	memcpy(&testPlayer, &basePlayer, sizeof(struct gameState));
        -:   53:
        -:   54:    // 2 Check deck count is equal for both
        4:   55:    fakeAssert( (*(int*)testPlayer.deckCount), (*(int*)basePlayer.deckCount), &ErrCnt);
call    0 returned 100%
        -:   56:
        -:   57:    //Add minion card to players hand at position 6
        4:   58:    testPlayer.hand[player][testPlayer.handCount[player]] = mine;
        4:   59:    testPlayer.handCount[player]++;
        -:   60:    
        -:   61:    // 3 Check that the mine card count is +1 for testplayer
       24:   62:    for (i = 0; i < basePlayer.handCount[player]; i++){
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
       20:   63:        if(basePlayer.hand[player+1][i] = mine);
       20:   64:			count++;
        -:   65:    }	
       28:   66:	for (i = 0; i < testPlayer.handCount[player]; i++){
branch  0 taken 86%
branch  1 taken 14% (fallthrough)
       24:   67:        if(testPlayer.hand[player][i] = mine);
       24:   68:			count2++;
        -:   69:    }
        4:   70:    fakeAssert(count+1, count2, &ErrCnt);
call    0 returned 100%
        -:   71:
        -:   72:    // 4 Check that the hand count increased
        4:   73:    fakeAssert(basePlayer.handCount[player] + 1, testPlayer.handCount[player], &ErrCnt);
call    0 returned 100%
        -:   74:    
        4:   75:    testPlayer.hand[player][0] = copper;
        4:   76:    testPlayer.hand[player][1] = gold;
        -:   77:    
        -:   78:    //Play mine card.
        4:   79:    cardEffect(mine, copper, gold, 0, &testPlayer, handpos, &bonus);
call    0 returned 100%
        -:   80:	
        -:   81:    /////////////////////////////////////////////
        -:   82:
        -:   83:	// 5 Check for introduced bug test player should not gain/discard card.
        4:   84:    fakeAssert((*(int*)testPlayer.handCount), (*(int*)basePlayer.handCount), &ErrCnt);
call    0 returned 100%
        -:   85:
        -:   86:    // 6 Check that test player has +2 coins vs base player
        4:   87:    fakeAssert(testPlayer.coins, basePlayer.coins+2, &ErrCnt);
call    0 returned 100%
        -:   88:    
        4:   89:}
        -:   90:
        -:   91:/*int refactoredMine(struct gameState *state, int choice1, int choice2, int currentPlayer, int handPos)
        -:   92:{
        -:   93:    int i;
        -:   94:    int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:   95:
        -:   96:        if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:   97:        {
        -:   98:            return -1;
        -:   99:        }
        -:  100:
        -:  101:        if (choice2 > treasure_map || choice2 < curse)
        -:  102:        {
        -:  103:            return -1;
        -:  104:        }
        -:  105:
        -:  106:        if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
        -:  107:        {
        -:  108:            return -1;
        -:  109:        }
        -:  110:
        -:  111:        //gainCard(choice2, state, 2, currentPlayer); BUG INTRODUCED
        -:  112:
        -:  113:        //discard card from hand
        -:  114:        //discardCard(handPos, currentPlayer, state, 0);  BUG INTRODUCED
        -:  115:
        -:  116:        //discard trashed card
        -:  117:        for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  118:        {
        -:  119:            if (state->hand[currentPlayer][i] == j)
        -:  120:            {
        -:  121:                discardCard(i, currentPlayer, state, 0);
        -:  122:                break;
        -:  123:            }
        -:  124:        }
        -:  125:
        -:  126:        return 0;
        -:  127:}*/
