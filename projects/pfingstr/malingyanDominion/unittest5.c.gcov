        -:    0:Source:unittest5.c
        -:    0:Graph:unittest5.gcno
        -:    0:Data:unittest5.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include <string.h>
        -:    4:#include <stdio.h>
        -:    5:#include <assert.h>
        -:    6:#include "rngs.h"
        -:    7:#define CARD_TEST "Tribute"
        -:    8:
        -:    9://gcc -o unittest5 dominion.c rngs.c unittest5.c .... /Desktop/cs362/CS362-F2019/projects/pfingstr/dominion
        -:   10:
function fakeAssert called 4 returned 100% blocks executed 75%
        4:   11:void fakeAssert(int i, int j, int *ErrCnt)
        -:   12:{
        4:   13:    if(i == j)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   14:    {
        4:   15:        printf("TEST %d PASSED\n", *ErrCnt);
call    0 returned 100%
        -:   16:    }
        -:   17:    else
        -:   18:    {
    #####:   19:        printf("TEST %d FAILED\n", *ErrCnt);
call    0 never executed
        -:   20:    }
        4:   21:    *ErrCnt = *ErrCnt+1;
        4:   22:}
        -:   23:
        -:   24:/* * If the player after you has fewer than 2 cards left in his deck, he reveals all 
        -:   25:         the cards in his deck, shuffles his discard pile (which does not include currently 
        -:   26:         revealed cards), and then reveals the remainder needed. The player then discards the revealed cards.
        -:   27:       * If the player after you does not have enough cards to reveal 2, he reveals what he can.
        -:   28:       * You get bonuses for the types of cards revealed, counting only the different cards.
        -:   29:       * A card with 2 types gives you both bonuses.
        -:   30:         So if the player to your left reveals Copper and Harem, you get +$4 and +2 cards; 
        -:   31:         if he reveals 2 Silvers, you just get +$2.  
        -:   32:         Changed: for (i = 0; i <= 2; i ++) {
        -:   33:        changed to: for (i = 0; i <= 1; i ++) {
        -:   34:        Impact: There will only be max +2 gold for the player.
        -:   35:        2. Removed: shuffle(nextPlayer,state);
        -:   36:    I   mpact: If there are no available cards for next player their deck will not be shuffled.*/
        -:   37:
function main called 1 returned 100% blocks executed 100%
        1:   38:int main() 
        -:   39:{
        -:   40:    //int i;
        1:   41:    int handpos = 0, bonus = 0;
        1:   42:    int seed = 1000;
        -:   43:    //number of players
        1:   44:    int numPlayers = 2;
        1:   45:    int player=0;
        -:   46:    //each holds a pointer to game state variable
        -:   47:	struct gameState basePlayer, testPlayer;
        -:   48:    //Kingdom cards avaliable for purchase
        1:   49:	int k[10] = {adventurer, embargo, village, minion, mine, cutpurse,
        -:   50:			sea_hag, tribute, smithy, council_room};
        1:   51:	int ErrCnt=1;
        -:   52:     //int count, count2;
        -:   53:    //count = count2 = 0;
        -:   54:
        -:   55:
        1:   56:    printf("TESTING - %s\n", CARD_TEST);
call    0 returned 100%
        -:   57:
        -:   58:	// 1 Initialize a game state and player cards
        1:   59:	fakeAssert(initializeGame(numPlayers, k, seed, &basePlayer), 0, &ErrCnt);
call    0 returned 100%
call    1 returned 100%
        -:   60:	//Copy the game state of player to testPlayer
        1:   61:	memcpy(&testPlayer, &basePlayer, sizeof(struct gameState));
        -:   62:    // 2 Check deck count is equal for both
        1:   63:    fakeAssert( (*(int*)testPlayer.deckCount), (*(int*)basePlayer.deckCount), &ErrCnt);
call    0 returned 100%
        -:   64:    // 3 Confirm 5 cards in each players deck
        1:   65:    fakeAssert( (*(int*)testPlayer.deckCount), 5, &ErrCnt);
call    0 returned 100%
        -:   66:    //Add tribute card to players hand
        1:   67:    testPlayer.hand[player][testPlayer.handCount[player]] = tribute;
        1:   68:    testPlayer.handCount[player]++;
        -:   69:    // 5 See if hand count +1
        1:   70:    fakeAssert(basePlayer.handCount[player] + 1, testPlayer.handCount[player], &ErrCnt);
call    0 returned 100%
        -:   71:   
        -:   72:    //Set player 1's total to 0. Try to catch bug 1
        1:   73:    testPlayer.deckCount[1]=0;
        -:   74:    //printf("%d\n", testPlayer.discardCount[1]+testPlayer.deckCount[1]);
        -:   75:    //Play tribute card with no options
        1:   76:    cardEffect(tribute, 0, 0, 0, &testPlayer, handpos, &bonus);
call    0 returned 100%
        -:   77:	
        -:   78:
        1:   79:    return 0;
        -:   80:
        -:   81:}
        -:   82:
        -:   83:/*int tributeEffect(int currentPlayer, struct gameState *state)
        -:   84:{
        -:   85:    int nextPlayer = currentPlayer + 1;
        -:   86:    int tributeRevealedCards[2] = {-1, -1};
        -:   87:    int i;
        -:   88:
        -:   89:    //tributeEffect() bug 1
        -:   90:    if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) < 1)
        -:   91:    {
        -:   92:
        -:   93:        // if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1) {
        -:   94:        if (state->deckCount[nextPlayer] > 0)
        -:   95:        {
        -:   96:            tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        -:   97:            state->deckCount[nextPlayer]--;
        -:   98:        }
        -:   99:        else if (state->discardCount[nextPlayer] > 0)
        -:  100:        {
        -:  101:            tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
        -:  102:            state->discardCount[nextPlayer]--;
        -:  103:        }
        -:  104:        else
        -:  105:        {
        -:  106:            //No Card to Reveal
        -:  107:            if (DEBUG)
        -:  108:            {
        -:  109:                printf("No cards to reveal\n");
        -:  110:            }
        -:  111:        }
        -:  112:    }
        -:  113:
        -:  114:    else
        -:  115:    {
        -:  116:        if (state->deckCount[nextPlayer] == 0)
        -:  117:        {
        -:  118:            for (i = 0; i < state->discardCount[nextPlayer]; i++)
        -:  119:            {
        -:  120:                state->deck[nextPlayer][i] = state->discard[nextPlayer][i]; //Move to deck
        -:  121:                state->deckCount[nextPlayer]++;
        -:  122:                state->discard[nextPlayer][i] = -1;
        -:  123:                state->discardCount[nextPlayer]--;
        -:  124:            }
        -:  125:
        -:  126:            shuffle(nextPlayer, state); //Shuffle the deck
        -:  127:        }
        -:  128:        tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        -:  129:        state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        -:  130:        state->deckCount[nextPlayer]--;
        -:  131:        tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        -:  132:        state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        -:  133:        state->deckCount[nextPlayer]--;
        -:  134:    }
        -:  135:
        -:  136:    if (tributeRevealedCards[0] == tributeRevealedCards[1])
        -:  137:    { //If we have a duplicate card, just drop one
        -:  138:        state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
        -:  139:        state->playedCardCount++;
        -:  140:        tributeRevealedCards[1] = -1;
        -:  141:    }
        -:  142:
        -:  143:    for (i = 0; i <= 2; i++)
        -:  144:    {
        -:  145:        if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold)
        -:  146:        { //Treasure cards
        -:  147:            state->coins += 2;
        -:  148:        }
        -:  149:
        -:  150:        else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall)
        -:  151:        { //Victory Card Found
        -:  152:            drawCard(currentPlayer, state);
        -:  153:            drawCard(currentPlayer, state);
        -:  154:        }
        -:  155:        else
        -:  156:        { //Action Card
        -:  157:
        -:  158:            //tributeEffect() bug 2
        -:  159:            state->numActions = state->numActions + 3;
        -:  160:            // state->numActions = state->numActions + 2;
        -:  161:        }
        -:  162:    }
        -:  163:    return 0;
        -:  164:}*/
